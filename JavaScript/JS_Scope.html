<!DOCTYPE html>
<html lang="en">

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>JavaScript Scope</title>
    <link rel="stylesheet" href="css/test-css.css">
</head>

<body>
    <header>
        <nav>
            <a href="index.html">Home</a>
            <a href="challenges/challenge22.html">C22</a>
            <a href="DOM_examples.html">DOM</a>
            <a href="DOM_examples2.html">DOM2</a>
            <a href="events.html">Events</a>
            <a href="events2.html">Events2</a>
            <a href="JS_Scope.html">JS-Scope</a>
        </nav>
    </header>

    <h1 class="center">This is a Java Script class test page!</h1><br><br>
    <h2>Scope in JS</h2>
    <h3>Scope in JavaScript has, historically, been problematic. Some
        variables are global and some are local to a function. <br> (Aside: It's
        not really a good thing to use the same variable for different
        things because scope can mess it up, which gets confusing.)
    </h3>
    <br>
    <h2>Namespacing & Closures</h2>
    <h3>You can wrap your code in an IIFE (immediately invoked function
        expression). This anonymous function runs as soon as the script loads,
        and it will also keep variables out of the global scope.</h3>
    <h4>Note: all functions are closures!</h4>
    <h4>The reason is that functions in JavaScript form closures. A closure is
        the combination of a function and the lexical environment within which
        that function was declared. This environment consists of any local
        variables that were in-scope at the time the closure was created.</h4>
    <br>
    <h2>"Use strict"</h2>
    <h3>ES5, which came out in 2009, included this directive to help cut down on
        accidental declarations of variables without using the var keyword.
    </h3>
    <br>
    <h2>const and let</h2>
    <h3>ES6 (ES 2015) introduced two new ways to declare variables in JS. They
        both help minimize the chances that a variable holds an unexpected value.
        <br>const cheese = "yummy";<br>
        The variable cheese can't hold any other value other than "yummy" for the
        life of the program. <br>
        The "let" keyword can change values, but it has block level scope.
    </h3>
    <br>
    <h2>Hoisting in JavaScript</h2>
    <h3>By default, JS hoists variables. This means you can use them before you
        specifically declare them. This can lead to unexpected results. <br>
        You should declare your variables first. <br>
        Const and Let are not hoisted.
    </h3>
    <br>


    <p>Here is a paragraph.</p>
    <p>Here is another paragraph.</p>
    <p>Here is one more paragraph.</p>
    <p>What? One more paragraph! This is getting crazy.</p>

    <br>

    <script>

        function testScope() {
            oopsGlobal = "This is accidentally global!";
            var aVariable = "This is in the local scope.";
            console.log(aVariable);
        }

        testScope();
        console.log(oopsGlobal);

        newVar = "not properly defined";
        console.log(newVar);

        var cheese = "yummy";
        console.log(cheese);

        console.log(cheese);
        const swissCheese = "yummy";

        for (let i=0; i<10; i++) {
            console.log(i);
        }
        console.log(`the value of i ${i}`);
        // "let" has block level scope. when we try to get the value of i, it will return an error

        (function() {
        var myPs = document.querySelectorAll('p');

            for ( i = 0; i<myPs.length; i++){
                myPs[i].style.color = "Olive";
            }
        }());

    </script>

</body>
</html>